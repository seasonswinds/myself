# 分布式锁

### 分布式锁应该具备哪些条件？

- 排他性。在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
- 高可用的获取锁与释放锁；
- 高性能的获取锁与释放锁；
- 具备可重入特性；
- 具备锁失效机制；
- 防止死锁，client最终归一定可以获取锁
- 集群容错性

### 分布式锁有哪些实现方式？

- 数据库实现（唯一主键约束）
- Redis实现（setNX）
- Redis实现（RedLock）？
- Zookeeper实现（临时顺序节点）
- Google chubby？

### Redis分布式锁解锁时应该注意什么

解锁很简单，只需要删除这个key就可以了。

删除之前需要判断，这个key对应的value是当初自己设置的那个。

### Redis分布式锁有哪些问题？

- setnx命令，设置过期时间非原子操作，有可能未设置过期时间宕机，导致过期时间未设置成功。

  > 解决：
  > 使用set(key，value ，expireTime，NX)
  > 原子操作

- 可能导致误删除。两个线程都来拿锁，A线程先获得锁之后，设置超时时间30s；在30s后线程还没执行到del命令行，这时锁就自己删掉了，这时候B线程就可以拿到锁，因此当A执行del的时候删掉的就是B的锁。

  > 解决：
  > 加锁时，值设置为线程id，删除时判断是否是自己的key
  > 获得锁的线程开启一个守护线程，为这个锁续时，每20s执行一次，给key延时20s

### Zookeeper分布式锁有哪些问题？

利用临时节点和watch机制。加锁时创建临时节点，创建成功则加锁成功，加锁失败则watch父节点，有删除操作再去竞争锁；释放锁时删除节点。

缺点：

- 所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。

  > 解决：
  >
  > 加锁改为创建临时有序节点，序号最小的加锁成功；不是最小的则watch前一个节点；watch事件到来之后再次判断是否最小。有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。

- 性能不如缓存分布式锁