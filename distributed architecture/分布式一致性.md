# 分布式一致性

### 什么是分布式系统？

> 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调。

### 分布式系统有哪些特征？

- 分布性

- 对等性

  > 所有计算机节点对等。
  >
  > 副本有两种
  >
  > - 数据副本：在不同节点上持久化同一份数据
  > - 服务副本：多个节点提供同样的服务；

- 并发性

- 缺乏全局时钟

  > 很难定义两个事件究竟谁先谁后

- 故障总是会发生

### 分布式环境会遇到的问题有哪些？

- 通信异常
  - 网络不可用
  - 消息丢失
  - 消息延时(超时)
- 网络分区——脑裂
- 三态
  - 成功
  - 失败
  - 超时
    - 消息没有被成功的发送到接收方，发送过程中丢失消息；
    - 消息成功被接受后，响应时丢失了消息；
- 节点故障

### 什么是CAP定理?

```
CAP理论告诉我们一个分布式系统不可能同时满足一致性、可用性和分区容错性。
```

- C(Consistency)一致性

  > 数据在多个副本之间是否能够保持一致性
  >
  > 放弃一致性，是指放弃数据的强一致性

- A(Availavility)可用性

  > 系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限地时间内返回结果
  >
  > 放弃可用性，是指在系统遇到故障时，受影响的服务需要等待一段时间，等待期间系统无法对外提供服务

- P(Partition tolerance)分区容错性

  > 分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务
  >
  > 放弃分区容错性，一种简单做法是将所有数据都放在一个分布式节点上，意味着放弃了可扩展性
  >
  > 对于分布式系统而言，分区容错性是一个基本要求

### 什么是BASE理论？

```
BASE是对CAP中一致性和可用性权衡的结果，核心思想是即使无法做到强一致性，但应用可以以适当的方式达到最终一致性。
```

- BA(Basically Available)基本可用

  > 在系统遇到故障的时候，允许系统损失部分可用性
  >
  > - 响应时间上损失
  > - 功能上损失

- S(Soft state)软状态

  > 允许系统中的数据存在中间状态，允许系统在不同副本之间的同步存在延时

- E(Eventually consistent)最终一致性

  > 系统中的所有副本，在经过一段时间同步后，最终能够达到一个一致状态
  >
  > - 因果一致性：A修改值后，通知B；B之后对数据的访问应该能获取到A修改之后的值
  > - 读己之所写
  > - 会话一致性
  > - 单调读一致性：如果一个进程从系统中读出一个数据项的某个值后，系统对于该进程后续的任何数据访问都不应该返回一个更旧的值
  > - 单调写一致性：保证来自同一个进程的写操作按顺序执行

### 什么是两阶段提交？

- 提交事务请求
  - 协调者向所有参与者发送事务请求，并等待各参与者响应
  - 各参与者节点执行事务操作
  - 各参与者向协调者反馈

- 执行事务提交(所有参与者都反馈Yes)
  - 协调者向所有参与者节点发送Commit请求
  - 参与者提交事务，并释放资源
  - 参与者向协调者发送Ack消息
  - 事务完成
- 事务中断(任何一个参与者反馈No，或等待超时)
  - 协调者向所有参与者发送Rollback请求
  - 参与者执行事务回滚操作
  - 参与者向协调者发送Ack消息
  - 完成事务中断

### 两阶段提交有什么问题？

- 同步阻塞

  > 执行过程中，所有参与事务操作的逻辑都处于阻塞状态，等待其他参与者响应过程中，无法进行任何其他操作。

- 单点

  > 协调者单点，一旦协调者故障，参与者会一直阻塞

- 数据不一致

  > 协调者发送commit消息后，发生网络故障，只有部分参与者接收到commit消息，导致数据不一致；

- 保守

  > 没有容错机制，任意一个节点失败都会导致整个事务失败

- 无法解决的问题

  > 协调者发出Commit消息后宕机，唯一接收到消息的参与者也宕机，即使重新选举出协调者，也无法确定该条事务的状态

### 什么是三阶段提交？

> 相对于两阶段提交
>
> - 引入超时机制
>   - PreCommit阶段，协调者等待参与者反馈超时，abort
>   - DoCommit阶段，参与者等待协调者发送指令超时，仍然完成提交
> - 增加一个准备阶段，保证在最后提交阶段前个参与节点状态一直

- CanCommit
  - 协调者向所有参与者询问是否可以执行事务，并等待各参与者响应
  - 参与者反馈
- PreCommit(所有参与者都反馈Yes)
  - 协调者向所有参与者发出preCommit请求，并进入prepared阶段
  - 参与者执行事务操作
  - 参与者向协调者反馈
- 中断事务(任何一个参与者反馈No，或者等待参与者反馈超时)
  - 协调者向所有参与者发送abort请求
  - 参与者中断事务(无论接收到abort请求或者等待超时)

- DoCommit(协调者接收到了所有参与者的Ack响应)

  > 参与者无法及时接收到来自协调者的DoCommit或者abort消息，会在等待超时后，继续进行事务提交

  - 协调者向所有参与者发送DoCommit请求
  - 参与者执行事务提交，释放资源
  - 参与者向协调者发送Ack消息
  - 协调者接收到所有参与者的Ack消息后，完成事务

- 中断事务(任何一个参与者反馈No)

  - 协调者向所有参与者发送abort请求
  - 参与者回滚事务
  - 参与者向协调者发送Ack消息
  - 协调者接收到所有参与者反馈的Ack消息后，中断事务

### 三阶段提交有哪些优缺点？

- 优点：
  - 降低了参与者的阻塞范围
  - 进入第三阶段后，即使协调者故障，事务仍能提交
- 缺点：
  - 参与者接收到PreCommit消息后，如果出现网络分区，如果协调者发出了abort请求，但参与者无法与协调者正常通信，参与者等待超时后依然会提交事务，导致数据不一致。

### Paxos算法流程

- Proposer选择一个提案编号$M_n$，向Acceptor的某个超过半数的子集成员发送Prepare请求

- Acceptor收到编号为$M_n$的Prepare请求，且编号$M_n$大于该Acceptor已经响应的所有Prepare请求的编号，则将已经批准的、最大编号的提案反馈给Proposer，同时承诺不再批准任何编号小于$M_n$的提案

  > 这里的Acceptor有三种情况
  >
  > - 未批准过提案 -> 返回“批准”
  > - 批准过提案
  >   - 批准过的提案的编号都小于当前提案编号$M_n$，返回批准，并附带之前批准过的编号最大的提案
  >   - 批准过的提案有编号大于当前提案编号$M_n$，返回驳回

- 如果Proposer收到半数以上Acceptor对于其发出的编号为$M_n$的Prepare请求的响应，发送一个针对$[M_n,V_n]$提案的Accept请求给Acceptor
  - $V_n$的值是收到的响应中编号最大的提案的值
  - 如果响应中不包含任何提案，$V_n$是任意值
  
- Acceptor接收到针对$[M_n,V_n]$提案的Accept请求，只要该Acceptor尚未对编号大于$M_n$的Prepare请求作出响应，则可以通过这个提案

### Paxos算法推导

> 要选定一个唯一提案的最简单方式，只允许一个Accpetor存在，Acceptor选择它接收到的第一个提案
>
> - 一旦Acceptor故障，整个系统无法工作
>
> 使用多个Acceptor来避免Acceptor单点问题，当有足够多的Acceptor批准提案时，提案被选定
>
> - 足够多：过半$$\frac{n}{2}+1$$，任意两个包含大多数Acceptor的子集至少有一个公共成员；
> - 每一个Acceptor只能批准一个提案

- **P1：一个Acceptor必须批准它收到的第一个提案**

  - 如果有多个提案被不通的Proposer同时提出，虽然每个Acceptor都批准了它收到的第一个提案，但是没有一个提案是由多数人批准的
  - 即使只有2个提案被提出，如果每个提案都被差不多一半的Acceptor批准了，此时即使只有一个Acceptor出错，都有可能导致无法确定该选哪个提案

- 由P1可知，每个Acceptor必须能够批准不止一个提案；

  [编号，Value]

  虽然允许多个提案被选定，必须要保证所有被选定的提案都具有相同的Value

- **P2：如果编号为$$M_0$$、Value值为$$V_0$$的提案（即$$[M_0, V_0]$$）被选定，那么所有比编号$$M_0$$更高的，且被选定的提案，其Value值必须也是$$V_0$$**

- **P2a：如果编号为$M_0$、Value值为$V_0$的提案（即$$[M_0, V_0]$$）被选定，那么所有比编号$M_0$高的，且被Acceptor批准的提案，其Value值也必须是$V_0$**

- **P2b：如果一个提案$$[M_0, V_0]$$被选定后，那么之后任何Proposer产生的编号更高的提案，其Value值都是$V_0$**

- **P2c：对于任意的$M_n$和$V_n$，如果提案$[M_n,V_n]$被提出，那么肯定存在一个有半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个**

  - **S中不存在任何批准过编号小于$M_n$的提案的Acceptor**
  - **选取S中所有Acceptor批准的编号小于$M_n$的提案，其中标号最大的那个提案Value是$V_n$**

### Paxos算法优化

- 允许Acceptor忽略任何请求
- Acceptor将批准的提案发送给一个特定的Learner集合
- 通过选取主Proposer保证算法活性

### ZAB(ZooKeeper Atomic Broadcast，Zookeeper原子消息广播)协议

> 支持崩溃恢复的原子广播协议
>
> 实现了一种主备模式的系统架构来保持集群数据一致性
>
> 使用一个单一主进程接收、处理客户端所有事务请求，并采用ZAB协议，将服务器数据状态变更以事务Proposal的形式广播到所有的副本进程
>
> ZAB协议能够保证一个全局的变更序列被顺序应用
>
> 消息广播协议基于有FIFO特性的TCP协议来进行网络通信，因此能保证消息广播过程中接收与发送的顺序性
>
> 崩溃恢复，高效且可靠的Leader选举算法

- 所有事务请求又一个全局唯一的服务器(Leader服务器)协调处理，其他服务器称谓Follower服务器
- Leader服务器负责讲一个客户端事务请求转换成一个Proposal(提议)，并分发给所有Follower服务器，等待Follower服务器反馈
- 一旦超过半数($\frac{n}{2}+1$)的Follower服务器进行了正确的反馈，Leader会再次向所有Follower服务器分发Commit消息

### ZAB协议流程

- 阶段一：发现
- 阶段二：同步
- 阶段三：广播

### Paxos算法与ZAB协议的联系与区别

- 联系
  - 都存在一个类似Leader的角色
  - Leader进程都会等待超过半数Follower做出正确反馈后，才提交一个提案
  - 都存在一个值表示当前Leader周期
- 区别
  - ZAB协议额外添加了一个同步阶段
  - 设计目标不同
    - Paxos算法用于构建一个分布式的一致性状态机系统
    - ZAB协议主要用于构建一个高可用的分布式数据主备系统

### 什么是分布式一致性？

### 分布式一致性分为哪些类型？

### 分布式系统达到一致性后将会是什么状态？

### 如果失去了一致性约束，分布式系统是否还可以依赖？

### 如果仅追求一致性，对系统整体架构和性能有多大影响？