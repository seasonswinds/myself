## InnoDB行锁，如何锁住一条不存在的记录

要细聊MySQL的行锁，难以避免的要从事务的四种隔离级别说起。

四种隔离级别，又脱不开聊脏读，不可重复读，幻读等问题。

事务隔离级别，行锁机制等都比较 **垂直** ，应用开发中大部分同学都用不到，不确定是否大部分朋友都感兴趣。

MySQL默认的事务隔离级别是 Repeated Read (RR)，假设使用的存储引擎是InnoDB，在这个隔离级别下：

> （1）读取到数据，都是其他事务已提交的数据；
> （2）同一个事务中，相同的连续读，得到的结果应该是相同的；
> （3）不会出现insert幻象读；

 

假设有数据表：
```
t(id int PK, name); 
```


假设目前的记录是：
```
10, shenjian
20, zhangsan
30, lisi
```
 

**Case 1**

事务A先执行，并且处于未提交状态：

```
update t set name='a' where id=10;
```

事务B后执行：

```
update t set name='b' where id=10;
```

因为事务A在PK id=10上加了 **行锁** ，因此事务B会阻塞。  

**Case 2**

事务A先执行，并且处于未提交状态：
```
delete from t where id=40;
```
事务A想要 **删除一条不存在的记录**。

事务B后执行：
```
insert into t values(40, 'c');
```
事务B想要 **插入一条主键不冲突的记录**。

**问题1**：事务B是否阻塞？
**问题2**：如果事务B阻塞，锁如何加在一条不存在的记录上呢？
**问题3**：事务的隔离级别，索引类型，是否对问题1和问题2有影响呢？
