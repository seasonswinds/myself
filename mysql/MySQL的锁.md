### 表锁

​	表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。

##### 优点

> - 实现逻辑非常简单，带来的系统负面影响最小
> - 获取锁和释放锁的速度很快
> - 可以很好的避免死锁

##### 缺点

> - 并发度低

### 行锁

##### 优点  

> - 锁定对象的粒度很小  
> - 并发度高  

##### 缺点

> - 消耗大  
> - 容易发生死锁

### 意向锁

​	如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，效率是非常低；

​	不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。

​	意向锁不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。

### InnoDB存储引擎有3种行锁:

- Record Lock：单个行记录上的锁。  

> ​Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。

- Gap Lock(间隙锁)：锁定一个范围，但不包含记录本身。

- Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。

> ​	Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，设计它的目的是用来解决Phontom Problem（幻读问题）。在MySQL默认的隔离级别（Repeatable Read）下，InnoDB就是使用它来解决幻读问题。
>
> ​	在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock。

### 一致性非锁定读

​	一致性非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过多版本控制（MVCC）的方式来读取当前执行时间数据库中行的数据。如果读取的这行正在执行DELETE或UPDATE操作，这时读取操作不会向XS锁一样去等待锁释放，而是会去读一个快照数据。

​	在事务隔离级别RC和RR下，InnoDB存储引擎使用非锁定的一致性读。

> - 在RC级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。
> - 而在RR级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。
