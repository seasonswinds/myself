# Java并发

### 为什么需要并发？

- 提高资源利用率
- 公平性
- 便利性

### 多线程带来的风险有哪些？

- 安全性问题

  > 安全性的含义是“永远不发生糟糕的事情”
  >
  > 在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的

- 活跃性问题

  > 活跃性的含义是“某件正确的事情最终会发生”

  - 死锁
  - 饥饿
  - 活锁

- 性能问题

  > 性能的含义是“正确的事情尽快发生”

  - 服务时间过长
  - 响应不灵敏
  - 吞吐率低
  - 资源消耗高
  - 可伸缩性低

### 线程安全的核心

> 要编写线程安全的代码，其核心在于要对状态访问操作进行管理
>
> 特别是对**共享的(Shared)**和**可变的(Mutable)**状态的访问

### 解决线程安全问题的途径有哪些？

- 不在线程间共享状态变量
- 将状态变量修改为不可变变量
- 在访问状态变量时使用同步

### 什么是线程安全性？

- 正确性

  > 某个类的行为与其规范完全一致
  >
  > 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的
  >
  > 无状态的对象一定是线程安全的

- 原子性

  > 假定有两个操作A和B，如果从执行A的线程看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的

- 可见性

  > 多个读线程在一个写操作后能读到相同的结果

### 用锁来保护状态

- 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁
- 每个共享的可变状态变量都应该只由一个锁来保护
- 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护

### 对象发布(Publish)

> 使对象能够在当前作用域之外的代码中使用
>
> 当某个不应该发布的对象被发布时，被称为**逸出(Escape)**

- 将一个指向该对象的引用保存到其他代码可以访问到的地方
- 在某一个非私有的方法中返回该引用
- 将引用传递到其他类的方法中
- 当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布

### 线程封闭

> 如果仅在单线程内访问数据，就不需要同步

- Ad-hoc线程封闭

  > 维护线程封闭性的职责完全由程序实现来承担

- 栈封闭——局部变量

  > 局部变量的固有属性之一就是封闭在线程中执行

- ThreadLocal

### 不可变对象

> 如果某个对象被创建之后其状态就不能被修改，那么这个对象就称为不可变对象
>
> 不可变对象一定是线程安全的
>
> 需同时满足以下条件：

- 对象创建后其状态就不能修改
- 对象的所有域都是final类型
- 对象是正确创建的

### 安全发布的常用模式

- 在静态初始化函数中初始化一个对象引用

  > 静态初始化器由JVM在类的初始化阶段执行。
  >
  > JVM内部存在同步机制

- 将对象引用保存到volatile类型的域或者AtomicReference对象中

- 将对象的引用保存到某个正确构造对象的final类型域中

- 将对象的引用保存到一个由锁保护的域中

### 安全发布

- 不可变对象可以通过任意机制发布
- 事实不可变对象必须通过安全方式发布
- 可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来

### 安全的使用和共享对象

- 线程封闭
- 只读共享
- 线程安全共享
- 保护对象

###ConcurrentHashMap

### CopyOnWriteArrayList

- 优点
  - 读的时候可以写入
- 缺点
  - 写入频繁时，copy很费时
  - 数据量大时，实时性较差(因为复制很费时)

- add
  - 加锁
  - 复制原数组
  - 添加元素
  - 替换原数组

### BlockingQueue

### DelayQueue

### 中断

> 并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己

- 响应中断
  - 传递异常
  - 恢复中断状态

### 闭锁

> 延迟线程的进度直到其到达终止状态
>
> 当闭锁到达结束状态后，将不会再改变状态
>
> 闭锁可以用来确保某些活动直到其他活动都完成后才继续执行
>
> 由AQS实现

- 确保某个计算在其需要的所有资源都被初始化之后才继续执行
- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动
- 等待直到某个操作的所有参与者都就绪再继续执行

### 信号量

> 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量
>
> 由AQS实现

### 栅栏

> 能阻塞一组线程直到某个事件发生
>
> 所有线程必须同时到达栅栏位置，才能继续执行
>
> 由ReentrantLock实现

### 闭锁(CountDownLatch)与栅栏(CyclicBarrier)有什么不同

- CountDownLatch参与线程角色不同，CyclicBarrier参与线程角色相同
- CountDownLatch是一次性的，CyclicBarrier可以循环使用

### ThreadLocal

- get

  - 获取当前调用线程

  - 获取ThreadLocalMap

    > 线程的内部变量
    >
    > 解决Hash冲突的策略是线性探测法

  - ThreadLocal自身作为key，获取值

    > ThreadLocalMap的Entry继承了弱引用，可以让无用的key及时回收
    >
    > 如果不使用remove()清除，有可能造成内存泄漏

    - 获取hash值

      > ThreadLocal有全局唯一的ID，每生成一个对象，自增

    - 计算桶位置

    - 如果对应位置的key值与当前值相同，返回

    - 如果不同，从当前位置开始遍历每个桶，直到遇到一个空桶

      > 如果超出桶数组范围，则从0开始继续遍历

      - 如果对应位置的key值与当前值相同，返回
      - 如果对应位置的key为null，删除结点

  - 返回值

- 使用需注意

  - 声明为static变量
  - 每次使用完，都要调用remove()，清除数据
  - InheritableThreadLocal并非线程安全

### 线程池

- Core Pool Size

  > 线程池的目标大小
  >
  > 即使没有任务执行时的线程池大象
  >
  > 只有在工作队列满了的情况下才会创建超出这个数量的线程

- Maximum Pool Size

  > 可同时活动的线程数量的上限

- 存活时间

- 任务队列

  - LinkedBlockingQueue
  - PriorityBlockingQueue
  - ArrayBlockingQueue
  - SynchronousQueue

- 饱和策略

  - 终止(Abort)，默认
  - 抛弃(Discard)
  - 抛弃最旧的(Discard-Oldest)
  - 调用者运行(Caller-Runs)

- 线程工厂

### ReadWriteLock

### StampedLock

### Phaser

### Exchanger

###sleep与wait有什么区别

- 原理不同

  - sleep是Thread类的静态方法

    > 使当前线程暂停执行指定的时间，而把执行机会（CPU时间片）让给其他的线程

  - wait是Object类的方法

    > 使当前拥有该对象锁的进程等待，直到其他线程调用notify方法才醒来，也可以指定时间自己醒来

- 对锁的处理机制不同
  - sleep方法不涉及锁操作，持有锁的线程sleep时不会释放锁
  - 调用wait方法的时候，线程会释放持有的锁
- 使用的区域不同
  - sleep方法可以放在任何地方使用
  - wait方法必须在同步控制方法或者同步语句块中使用
- 中断
  - sleep可中断
  - wait不可中断