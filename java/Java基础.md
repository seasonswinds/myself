# Java基础

### HashMap

- treeifyBin()

  - 如果**未初始化**或**桶数组长度小于64**
    - 初始化、扩容，resize()
  - 转换成TreeNode链表
  - 将新建的TreeNode组成的链表整理成红黑树

- resize()

  - 计算桶数组大小
  - 遍历每个桶
    - 如果原桶为空，不处理
    - 如果原桶内只有一个节点，重新计算hash，定位新的桶位置
    - 如果原桶内是红黑树，split()
      - 按序分成两个链表(红黑树本身也是一个双向链表)，分别置入相应的新桶位置
        - 如果链表长度小于等于6，转换为链表
        - 如果链表长度大于6，转换为红黑树
    - 如果原桶内是链表，按序分成两个链表，分别置入相应的新桶位置

- HashMap的线程不安全体现在哪？

  - 多线程put时，可能造成数据丢失
  - resize()时，可能行成循环链表(jdk1.8修复，头插改为尾插)

  - 使用迭代器时fail-fast

    > 使用迭代器过程中，如果HashMap被修改，抛出ConcurrentModificationException

### ConcurrentHashMap

- get
  
  - 计算hash
  - 取出桶位节点
  - 如果桶位节点hash值与查询key值hash相同
    - 判断key值是否相同，相同则返回值
  - 如果桶位hash<0
    - FWD节点，在nextTable里查找
    - 红黑树节点，在树里查找
  - 链表查询
  
- putVal
  
  - ```if(key == null || value == null) throw new NullPointerException();```
  - 计算hash
  - 循环
    - 如果桶数组未初始化，先初始化
    - 如果当前hash值对应的桶为空，使用CAS方式添加结点，成功后退出循环
    - 如果当前hash值对应的桶正在转移(rehash)，当前线程加入帮助转移
    - 对当前桶加锁，添加节点
      - 判断将要操作的节点未发生变化，防止并发的rehash导致桶已经迁移；
      - 如果是链表
        - 遍历链表查找key
        - 找到之后替换
        - 未找到则新建节点加入链表尾
        - 计算链表长度
      - 如果是红黑树，向红黑树中添加结点
      - 如果链表长度超过8，转成红黑树
      - 跳出循环
  - 计数加1
  
- transfer

  - 计算每个线程可以处理的桶区间，默认 16。

  - 如果nextTable尚未初始化，进行初始化，扩容 2 倍。
  
  - 创建ForwardingNode节点，占位，当别的线程发现这个槽位中是 fwd 类型的节点，则跳过这个节点。
  
  - 循环
  
    - 计算需要处理的桶位
      - 向前推进一个桶位，--i。
      - 如果当前桶位大于边界或者transfer过程已完成，停止推进
      - 如果transferIndex <= 0，表示transfer过程已经完成，停止推进
      - 为当前线程选定区域，停止推进
    - 如果i不是有效值(不在桶数组长度范围内)
      - 如果扩容完成，更换桶数组，退出方法
      - sc - 1
      - 判断是否完成transfer
  
    - 如果当前桶位为null，使用ForwardingNode节点占位
  
    - 如果当前桶位hash值是MOVED，有其他线程在处理，跳过
  
    - transfer该桶位
  
      - 对桶位加锁
  
        > 防止putVal时向桶位插入数据
  
      - 如果桶位上是链表
  
        - 生成两个链表
        - 分别设置到新桶数组中
        - 当前桶用ForwardingNode节点占位
  
      - 如果桶位上是红黑树
  
        - 生成两个链表
        - 如果节点数量小于等于6，保留链表
        - 如果节点数量大于6，转成红黑树
        - 分别设置到新桶数组中
        - 当前桶用ForwardingNode节点占位
  